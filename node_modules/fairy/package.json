{
  "author": {
    "name": "Baoshan Sheng",
    "email": "sheng@icmd.org",
    "url": "https://github.com/baoshan"
  },
  "name": "fairy",
  "description": "Queue System Treats Tasks Fairly.",
  "version": "0.0.5",
  "homepage": "https://github.com/baoshan/fairy",
  "repository": {
    "type": "git",
    "url": "git://github.com:baoshan/fairy.git"
  },
  "main": "lib/fairy.js",
  "dependencies": {
    "redis": "*",
    "node-uuid": "*",
    "express": "*"
  },
  "devDependencies": {
    "mocha": "*",
    "should": "*",
    "coffee-script": "*"
  },
  "optionalDependencies": {},
  "engines": {
    "node": "*"
  },
  "readme": "[![build status](https://secure.travis-ci.org/baoshan/fairy.png)](http://travis-ci.org/baoshan/fairy)\n## Redis Queue Battles Message Groups!\n\n**Fairy** is a lightweight queue engine for node.js based on Redis. **Fairy**\noffers ActiveMQ's **[message groups]** alike feature which can guarantee\nthe sequential processing order of tasks belong to a same group.\n\n[Message Groups]: http://activemq.apache.org/message-groups.html\n\nBut, unlike **message groups**, **Fairy** doesn't always route tasks of a\ngroup to a same worker, which will introduce unwanted waiting time when:\n\n  1. Tasks of group `X` and `Y` are appointed to worker `A`.\n  2. Worker `A` is processing tasks of group `X` **sequentially**.\n  3. Tasks of group `Y` are pending, while:\n  4. Worker `B` is still idling because of 1.\n\n**Fairy** will route the task of group `Y` to worker `B` in this scenario.\n\n**Fairy** takes a different approach than Message Groups. Instead of making\nall tasks of a same group be routed to the same consumer, **Fairy** route a\ntask to any worker when there's no **processing** tasks of the same group.\n\nThe design philosophy makes **Fairy** ideal for the following requirements:\n\n  + Tasks of a same groups need be processed in sequence.\n  + Each worker processes tasks in serial.\n  + Multiple workers need be instantiated to increase throughput.\n\n**Fairy** takes a different approach than Message Groups. Instead of making all\ntasks of a same group be routed to the same consumer, **Fairy** route a task to\nany worker when there's no **processing** tasks of the **same group**.\n\nWhen the number of workers is much smaller compared to the number of groups,\n**Fairy**'s approach makes sense.\n\n**[Resque]** cannot guarantee the processing order of the tasks although the task\nqueue is FIFO. The more workers you have, the more possible you'll encountering\nconcurrency which breaks the processing order of tasks in the same group.\n\n[Resque]: https://github.com/defunkt/resque\n\n## Installation\n\n    npm install fairy\n\n## Get Started\n\nThe minimium set of APIs you need to learn in order to implement a task queue\nsystem are:\n\n  + `enqueue` tasks, and\n  + `regist` a function for processing them.\n\n### Enqueue Tasks\n\nProvide as many parameters as you want (and an optional callback function).\nThe first argument will be used for message grouping.\n\n    queue = require('fairy').connect().queue('task_name')\n    queue.enqueue 'foo', 'bar', ->\n      console.log 'your order has been placed, sir.'\n\n### Register Task Handler\n\nWhen registered a task handler, the **Fairy** queue becomes a worker\nautomatically.\n\nThe registered handler function will be called when there're tasks to be\nprocessed, with the enqueued parameters of the task. The last argument will be a\n**non**-optional callback function.\n\nArguments of the callback function follow node.js error handling convention:\n`err` and `res`.\n\nCalling the callback function is your responsibility (or **Fairy** will not\ndispatch tasks to the worker and block tasks of the same group forever!)\n\n    queue = require('fairy').connect().queue('task_name')\n    queue.regist (param1, param2, callback) ->\n      # Do your work here, be it synchronous or asynchronous.\n      callback err, res\n\n## Web Front-End\n\n**Fairy** comes with a ready-to-use web front-end. Simply insert the middleware into\nthe pipeline:\n\n    app = require('express').createServer()\n    fairy_web = require 'fairy/web'\n    app.use fairy_web.connect().middleware\n    app.listen 3000\n\n## More APIs\n\nMore APIs include:\n\n1. Objects of Class `Queue`:\n  + Placing tasks -- `enqueue`\n  + Regist handlers -- `regist`\n  + Reschedule tasks -- `reschedule`\n  + Query status --\n    - `recently_finished_tasks`\n    - `failed_tasks`\n    - `blocked_groups`\n    - `slowest_tasks`\n    - `processing_tasks`\n    - `workers`\n    - `statistics`, etc.\n2. Objects of Class `Fairy`:\n  + `queues`, return all queues.\n  + `statistics`, return statistics of all queues.\n\nSee **[Example Folder]** for demos. Or review the **[Annotated Source Code]**\nfor complete API explanations.\n\n[Example Folder]:        https://github.com/baoshan/fairy/tree/master/example\n[Annotated Source Code]: http://baoshan.github.com/fairy/src/fairy.html\n\n## License\n\nCopyright (c) 2012 Baoshan Sheng\n\nReleased under the MIT license.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/baoshan/fairy/issues"
  },
  "_id": "fairy@0.0.5",
  "_from": "fairy@*"
}
