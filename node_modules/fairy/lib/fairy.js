// Generated by CoffeeScript 1.7.1
(function() {
  var Fairy, Module, Queue, Worker, capturable_signals, clean_up, close_callback, cluster, create_client, domain, exiting, fairy_id, first_time, log_registered_workers, os, prefix, redis, registered_workers, server_ip, soft_kill_signal, uncaught_exception_happened, uuid, workers, _fn, _i, _len,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __slice = [].slice;

  redis = require('redis');

  uuid = require('node-uuid');

  os = require('os');

  domain = require('domain');

  prefix = 'FAIRY';

  Module = (function() {
    function Module() {}

    Module.prototype.connect = function(options) {
      if (options == null) {
        options = {};
      }
      return new Fairy(options);
    };

    Module.prototype.version = require(__dirname + '/../package.json').version;

    return Module;

  })();

  module.exports = new Module;

  exiting = false;

  close_callback = null;

  registered_workers = [];

  log_registered_workers = function() {
    var worker, _i, _len, _results;
    console.log("\nFairy is waiting for " + workers.length + " workers to clean-up before exit:");
    _results = [];
    for (_i = 0, _len = workers.length; _i < _len; _i++) {
      worker = workers[_i];
      _results.push(console.log("  * Client Id: [" + worker.fairy.id + "], Task: [" + worker.name + "]"));
    }
    return _results;
  };

  workers = [];

  first_time = true;

  clean_up = function(callback) {
    var worker, _i, _len, _results;
    if (!callback) {
      if (!first_time) {
        log_registered_workers();
      }
      first_time = false;
    }
    if (!workers.length) {
      return setTimeout((function() {
        if (callback) {
          return callback();
        } else {
          return process.exit(uncaught_exception_happened ? 8 : 0);
        }
      }), 0);
    }
    exiting = true;
    _results = [];
    for (_i = 0, _len = workers.length; _i < _len; _i++) {
      worker = workers[_i];
      if (worker.is_idling) {
        _results.push(worker.unregist(callback));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  capturable_signals = ['SIGINT', 'SIGHUP', 'SIGQUIT', 'SIGUSR1', 'SIGUSR2', 'SIGTERM', 'SIGABRT'];

  uncaught_exception_happened = false;

  process.on('uncaughtException', function(err) {
    uncaught_exception_happened = true;
    console.log('Exception:', err.stack);
    if (registered_workers.length) {
      console.log('Fairy workers will block their processing groups before exit.');
    }
    return clean_up();
  });

  cluster = require('cluster');

  _fn = function(soft_kill_signal) {
    return process.on(soft_kill_signal, function() {
      var id, wait_workers_exit, worker, _ref;
      _ref = cluster.workers;
      for (id in _ref) {
        worker = _ref[id];
        worker.process.kill(soft_kill_signal);
        worker.suicide = true;
      }
      return (wait_workers_exit = function() {
        if (cluster.workers && Object.keys(cluster.workers).length) {
          return setTimeout(wait_workers_exit, 100);
        }
        return clean_up();
      })();
    });
  };
  for (_i = 0, _len = capturable_signals.length; _i < _len; _i++) {
    soft_kill_signal = capturable_signals[_i];
    _fn(soft_kill_signal);
  }

  server_ip = function() {
    var address, addresses, card, _j, _len1, _ref;
    _ref = os.networkInterfaces();
    for (card in _ref) {
      addresses = _ref[card];
      for (_j = 0, _len1 = addresses.length; _j < _len1; _j++) {
        address = addresses[_j];
        if (!address.internal && address.family === 'IPv4') {
          return address.address;
        }
      }
    }
    return 'UNKNOWN_IP';
  };

  create_client = function(options) {
    var client;
    client = redis.createClient(options.port, options.host, options.options);
    if (options.password != null) {
      client.auth(options.password);
    }
    return client;
  };

  fairy_id = 0;

  Fairy = (function() {
    function Fairy(options) {
      this.options = options;
      this.statistics = __bind(this.statistics, this);
      this.queues = __bind(this.queues, this);
      this.redis = create_client(options);
      this.pubsub = create_client(options);
      this.id = fairy_id++;
      this.queue_pool = {};
    }

    Fairy.prototype.key = function(key) {
      return "" + prefix + ":" + key;
    };

    Fairy.prototype.queue = function(name) {
      if (this.queue_pool[name]) {
        return this.queue_pool[name];
      }
      this.redis.sadd(this.key('QUEUES'), name);
      return this.queue_pool[name] = new Queue(this, name);
    };

    Fairy.prototype.queues = function(callback) {
      return this.redis.smembers(this.key('QUEUES'), (function(_this) {
        return function(err, res) {
          if (err) {
            return callback(err);
          }
          return callback(null, res.map(function(name) {
            return _this.queue(name);
          }));
        };
      })(this));
    };

    Fairy.prototype.statistics = function(callback) {
      return this.queues(function(err, queues) {
        var i, queue, result, total_queues, _j, _len1, _results;
        if (err) {
          return callback(err);
        }
        if (!(total_queues = queues.length)) {
          return callback(null, []);
        }
        result = [];
        _results = [];
        for (i = _j = 0, _len1 = queues.length; _j < _len1; i = ++_j) {
          queue = queues[i];
          _results.push((function(queue, i) {
            return queue.statistics(function(err, statistics) {
              if (err) {
                return callback(err);
              }
              result[i] = statistics;
              if (!--total_queues) {
                if (callback) {
                  return callback(null, result);
                }
              }
            });
          })(queue, i));
        }
        return _results;
      });
    };

    Fairy.prototype.close = clean_up;

    return Fairy;

  })();

  Queue = (function() {
    function Queue(fairy, name) {
      this.fairy = fairy;
      this.name = name;
      this.workers = __bind(this.workers, this);
      this.failed_tasks = __bind(this.failed_tasks, this);
      this.recently_finished_tasks = __bind(this.recently_finished_tasks, this);
      this.clear = __bind(this.clear, this);
      this.reschedule = __bind(this.reschedule, this);
      this.regist = __bind(this.regist, this);
      this.enqueue = __bind(this.enqueue, this);
      this.redis = fairy.redis, this.pubsub = fairy.pubsub;
    }

    Queue.prototype.key = function(key) {
      return "" + prefix + ":" + key + ":" + this.name;
    };

    Queue.prototype.retry_limit = 2;

    Queue.prototype.retry_delay = 0.1 * 1000;

    Queue.prototype.recent_size = 10;

    Queue.prototype.slowest_size = 10;

    Queue.prototype.enqueue = function() {
      var args, callback, group, _j;
      group = arguments[0], args = 3 <= arguments.length ? __slice.call(arguments, 1, _j = arguments.length - 1) : (_j = 1, []), callback = arguments[_j++];
      if (typeof callback !== 'function') {
        args.push(callback);
        callback = void 0;
      }
      return this.redis.multi().rpush(this.key('SOURCE'), JSON.stringify([uuid.v4(), group].concat(__slice.call(args), [Date.now()]))).sadd(this.key('GROUPS'), group).hincrby(this.key('STATISTICS'), 'TOTAL', 1).publish(this.key('ENQUEUED'), null).exec(callback);
    };

    Queue.prototype.regist = function(handler) {
      return workers.push(new Worker(this, handler));
    };

    Queue.prototype.reschedule = function(callback) {
      var client, reschedule;
      client = create_client(this.fairy.options);
      return (reschedule = (function(_this) {
        return function() {
          client.watch(_this.key('FAILED'));
          client.watch(_this.key('SOURCE'));
          client.watch(_this.key('BLOCKED'));
          client.watch(_this.key('PROCESSING'));
          return client.hlen(_this.key('PROCESSING'), function(err, res) {
            if (res) {
              client.unwatch();
              return reschedule();
            }
            return _this.failed_tasks(function(err, tasks) {
              var requeued_tasks;
              requeued_tasks = [];
              requeued_tasks.push.apply(requeued_tasks, tasks.map(function(task) {
                return JSON.stringify([task.id].concat(__slice.call(task.params), [task.queued.valueOf()]));
              }));
              return _this.blocked_groups(function(err, groups) {
                var group, start_transaction, total_groups, _j, _len1, _results;
                if (groups.length) {
                  client.watch.apply(client, groups.map(function(group) {
                    return "" + (_this.key('QUEUED')) + ":" + group;
                  }));
                }
                start_transaction = function() {
                  var multi;
                  multi = client.multi();
                  if (requeued_tasks.length) {
                    multi.lpush.apply(multi, [_this.key('SOURCE')].concat(__slice.call(requeued_tasks.reverse())));
                  }
                  multi.del(_this.key('FAILED'));
                  if (groups.length) {
                    multi.del.apply(multi, groups.map(function(group) {
                      return "" + (_this.key('QUEUED')) + ":" + group;
                    }));
                  }
                  multi.del(_this.key('BLOCKED'));
                  return multi.exec(function(multi_err, multi_res) {
                    if (multi_err) {
                      client.quit();
                      return callback(multi_err);
                    }
                    if (multi_res) {
                      client.quit();
                      _this.redis.publish(_this.key('ENQUEUED'), "");
                      return _this.statistics(callback);
                    } else {
                      return reschedule(callback);
                    }
                  });
                };
                if (total_groups = groups.length) {
                  _results = [];
                  for (_j = 0, _len1 = groups.length; _j < _len1; _j++) {
                    group = groups[_j];
                    _results.push(client.lrange("" + (_this.key('QUEUED')) + ":" + group, 1, -1, function(err, res) {
                      requeued_tasks.push.apply(requeued_tasks, res);
                      if (!--total_groups) {
                        return start_transaction();
                      }
                    }));
                  }
                  return _results;
                } else {
                  return start_transaction();
                }
              });
            });
          });
        };
      })(this))();
    };

    Queue.prototype.clear = function(callback) {
      this.redis.watch(this.key('SOURCE'));
      this.redis.watch(this.key('PROCESSING'));
      return this.redis.hlen(this.key('PROCESSING'), (function(_this) {
        return function(err, processing) {
          if (err) {
            return typeof callback === "function" ? callback(err) : void 0;
          }
          return _this.redis.keys("" + (_this.key('QUEUED')) + ":*", function(err, res) {
            var _ref;
            if (err) {
              return typeof callback === "function" ? callback(err) : void 0;
            }
            return (_ref = _this.redis.multi()).del.apply(_ref, [_this.key('GROUPS'), _this.key('RECENT'), _this.key('FAILED'), _this.key('SOURCE'), _this.key('STATISTICS'), _this.key('SLOWEST'), _this.key('BLOCKED')].concat(__slice.call(res))).hmset(_this.key('STATISTICS'), 'TOTAL', processing, 'FINISHED', 0, 'TOTAL_PENDING_TIME', 0, 'TOTAL_PROCESS_TIME', 0).exec(function(err, res) {
              if (err) {
                return typeof callback === "function" ? callback(err) : void 0;
              }
              if (!res) {
                return _this.clear(callback);
              }
              if (callback) {
                return _this.statistics(callback);
              }
            });
          });
        };
      })(this));
    };

    Queue.prototype.recently_finished_tasks = function(callback) {
      return this.redis.lrange(this.key('RECENT'), 0, -1, function(err, res) {
        if (err) {
          return callback(err);
        }
        return callback(null, res.map(function(entry) {
          entry = JSON.parse(entry);
          return {
            id: entry[0],
            params: entry.slice(1, -2),
            finished: new Date(entry.pop()),
            queued: new Date(entry.pop())
          };
        }));
      });
    };

    Queue.prototype.failed_tasks = function(callback) {
      return this.redis.lrange(this.key('FAILED'), 0, -1, function(err, res) {
        if (err) {
          return callback(err);
        }
        return callback(null, res.map(function(entry) {
          entry = JSON.parse(entry);
          return {
            id: entry[0],
            params: entry.slice(1, -3),
            reason: entry.pop(),
            failed: new Date(entry.pop()),
            queued: new Date(entry.pop())
          };
        }));
      });
    };

    Queue.prototype.blocked_groups = function(callback) {
      return this.redis.smembers(this.key('BLOCKED'), function(err, res) {
        if (err) {
          return callback(err);
        }
        return callback(null, res.map(function(entry) {
          return entry = JSON.parse(entry);
        }));
      });
    };

    Queue.prototype.slowest_tasks = function(callback) {
      return this.redis.zrevrange(this.key('SLOWEST'), 0, -1, "WITHSCORES", function(err, res) {
        var i;
        if (err) {
          return callback(err);
        }
        res = res.map(function(entry) {
          return JSON.parse(entry);
        });
        return callback(null, ((function() {
          var _j, _ref, _results;
          _results = [];
          for (i = _j = 0, _ref = res.length; _j < _ref; i = _j += 2) {
            _results.push(__slice.call(res[i]).concat([res[i + 1]]));
          }
          return _results;
        })()).map(function(entry) {
          return {
            id: entry[0],
            params: entry.slice(1, -3),
            time: entry.pop(),
            started: new Date(entry.pop()),
            queued: new Date(entry.pop())
          };
        }));
      });
    };

    Queue.prototype.processing_tasks = function(callback) {
      return this.redis.hvals(this.key('PROCESSING'), function(err, res) {
        if (err) {
          return callback(err);
        }
        return callback(null, res.map(function(entry) {
          entry = JSON.parse(entry);
          return {
            id: entry[0],
            params: entry.slice(1, -2),
            start: new Date(entry.pop()),
            queued: new Date(entry.pop())
          };
        }));
      });
    };

    Queue.prototype.source_tasks = function() {
      var args, callback, skip, take, _j;
      args = 2 <= arguments.length ? __slice.call(arguments, 0, _j = arguments.length - 1) : (_j = 0, []), callback = arguments[_j++];
      skip = args[0] || 0;
      take = args[1] || 10;
      return this.redis.lrange(this.key('SOURCE'), skip, skip + take - 1, function(err, res) {
        if (err) {
          callback(err);
        }
        return callback(null, res.map(function(entry) {
          entry = JSON.parse(entry);
          return {
            id: entry[0],
            params: entry.slice(1, -1),
            queued: new Date(entry.pop())
          };
        }));
      });
    };

    Queue.prototype.workers = function(callback) {
      return this.redis.hvals(this.key('WORKERS'), function(err, res) {
        if (err) {
          return callback(err);
        }
        return callback(null, res.map(function(entry) {
          entry = entry.split('|');
          return {
            host: entry[0],
            ip: entry[1],
            pid: parseInt(entry[2]),
            since: new Date(parseInt(entry[3]))
          };
        }).sort(function(a, b) {
          if (a.ip > b.ip) {
            return 1;
          }
          if (a.ip < b.ip) {
            return -1;
          }
          if (a.pid > b.pid) {
            return 1;
          }
          if (a.pid < b.pid) {
            return -1;
          }
        }));
      });
    };

    Queue.prototype.statistics = function(callback) {
      return this.redis.multi().scard(this.key('GROUPS')).hgetall(this.key('STATISTICS')).hlen(this.key('PROCESSING')).llen(this.key('FAILED')).smembers(this.key('BLOCKED')).hlen(this.key('WORKERS')).exec((function(_this) {
        return function(multi_err, multi_res) {
          var group, multi2, result, statistics, _j, _len1, _ref;
          if (multi_err) {
            return callback(multi_err);
          }
          statistics = multi_res[1] || {};
          result = {
            name: _this.name,
            total: {
              groups: multi_res[0],
              tasks: parseInt(statistics.TOTAL) || 0
            },
            finished_tasks: parseInt(statistics.FINISHED) || 0,
            average_pending_time: Math.round(statistics.TOTAL_PENDING_TIME * 100 / statistics.FINISHED) / 100,
            averageprocess_time: Math.round(statistics.TOTAL_PROCESS_TIME * 100 / statistics.FINISHED) / 100,
            blocked: {
              groups: multi_res[4].length
            },
            processing_tasks: multi_res[2],
            failed_tasks: multi_res[3],
            workers: multi_res[5]
          };
          if (result.finished_tasks === 0) {
            result.average_pending_time = '-';
            result.averageprocess_time = '-';
          }
          multi2 = _this.redis.multi();
          _ref = multi_res[4];
          for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
            group = _ref[_j];
            multi2.llen("" + (_this.key('QUEUED')) + ":" + group);
          }
          return multi2.exec(function(multi2_err, multi2_res) {
            if (multi2_err) {
              return callback(multi2_err);
            }
            result.blocked.tasks = multi2_res.reduce((function(a, b) {
              return a + b;
            }), -result.blocked.groups);
            result.pending_tasks = result.total.tasks - result.finished_tasks - result.processing_tasks - result.failed_tasks - result.blocked.tasks;
            return callback(null, result);
          });
        };
      })(this));
    };

    return Queue;

  })();

  Worker = (function() {
    function Worker(queue, handler) {
      this.queue = queue;
      this.handler = handler;
      this.unregist = __bind(this.unregist, this);
      this.requeue = __bind(this.requeue, this);
      this.continue_group = __bind(this.continue_group, this);
      this.process = __bind(this.process, this);
      this.start = __bind(this.start, this);
      this.name = queue.name, this.fairy = queue.fairy, this.redis = queue.redis, this.pubsub = queue.pubsub;
      this.id = uuid.v4();
      this.redis.hset(this.key('WORKERS'), this.id, "" + (os.hostname()) + "|" + (server_ip()) + "|" + process.pid + "|" + (Date.now()));
      process.on('uncaughtException', (function(_this) {
        return function(err) {
          if (_this._handler_callback) {
            console.log("Worker [" + (_this.id.split('-')[0]) + "] registered for Task [" + _this.name + "] will block its current processing group");
            return _this._handler_callback({
              "do": 'block',
              message: err.stack
            });
          } else {
            return _this.unregist();
          }
        };
      })(this));
      this.pubsub.subscribe(this.key('ENQUEUED'));
      this.pubsub.on('message', (function(_this) {
        return function(channel, message) {
          if (channel !== _this.key('ENQUEUED')) {
            return;
          }
          _this._new_task = true;
          if (_this.is_idling) {
            return _this.start();
          }
        };
      })(this));
      this.start();
    }

    Worker.prototype.key = function(key) {
      return "" + prefix + ":" + key + ":" + this.name;
    };

    Worker.prototype.start = function() {
      this.is_idling = this._new_task = false;
      if (exiting) {
        return this.unregist();
      }
      this.redis.watch(this.key('SOURCE'));
      return this.redis.lindex(this.key('SOURCE'), 0, (function(_this) {
        return function(err, res) {
          var task;
          if (task = JSON.parse(res)) {
            return _this.redis.multi().lpop(_this.key('SOURCE')).rpush("" + (_this.key('QUEUED')) + ":" + task[1], res).exec(function(multi_err, multi_res) {
              if (!(multi_res && multi_res[1] === 1)) {
                return _this.start();
              }
              return _this.process(task);
            });
          } else {
            _this.redis.unwatch();
            return _this.is_idling = true;
          }
        };
      })(this));
    };

    Worker.prototype.process = function(task) {
      var call_handler, d, errors, handler_callback, processing, retry_count, start_time;
      this.redis.hset(this.key('PROCESSING'), task[0], JSON.stringify(__slice.call(task).concat([start_time = Date.now()])));
      processing = task[0];
      retry_count = this.retry_limit;
      errors = [];
      this._handler_callback = handler_callback = (function(_this) {
        return function(err, res) {
          var finish_time, process_time;
          _this._handler_callback = null;
          if (err) {
            errors.push(err.message || null);
            switch (err["do"]) {
              case 'block':
                _this.redis.multi().rpush(_this.key('FAILED'), JSON.stringify(__slice.call(task).concat([Date.now()], [errors]))).hdel(_this.key('PROCESSING'), processing).sadd(_this.key('BLOCKED'), task[1]).exec();
                return _this.start();
              case 'block-after-retry':
                if (retry_count--) {
                  return setTimeout(call_handler, _this.retry_delay);
                }
                _this.redis.multi().rpush(_this.key('FAILED'), JSON.stringify(__slice.call(task).concat([Date.now()], [errors]))).hdel(_this.key('PROCESSING'), processing).sadd(_this.key('BLOCKED'), task[1]).exec();
                return _this.start();
              default:
                if (retry_count--) {
                  return setTimeout(call_handler, _this.retry_delay);
                }
                _this.redis.multi().rpush(_this.key('FAILED'), JSON.stringify(__slice.call(task).concat([Date.now()], [errors]))).hdel(_this.key('PROCESSING'), processing).exec();
            }
          } else {
            finish_time = Date.now();
            process_time = finish_time - start_time;
            _this.redis.multi().hdel(_this.key('PROCESSING'), processing).hincrby(_this.key('STATISTICS'), 'FINISHED', 1).hincrby(_this.key('STATISTICS'), 'TOTAL_PENDING_TIME', start_time - task[task.length - 1]).hincrby(_this.key('STATISTICS'), 'TOTAL_PROCESS_TIME', process_time).lpush(_this.key('RECENT'), JSON.stringify(__slice.call(task).concat([finish_time]))).ltrim(_this.key('RECENT'), 0, _this.recent_size - 1).zadd(_this.key('SLOWEST'), process_time, JSON.stringify(__slice.call(task).concat([start_time]))).zremrangebyrank(_this.key('SLOWEST'), 0, -_this.slowest_size - 1).exec();
          }
          return _this.continue_group(task[1]);
        };
      })(this);
      d = domain.create();
      d.on('error', (function(_this) {
        return function(error) {
          return _this.redis.multi().rpush(_this.key('FAILED'), JSON.stringify(__slice.call(task).concat([Date.now()], [errors]))).hdel(_this.key('PROCESSING'), processing).sadd(_this.key('BLOCKED'), task[1]).exec(function(err, res) {
            exiting = true;
            return _this.unregist();
          });
        };
      })(this));
      return d.run(call_handler = (function(_this) {
        return function() {
          return _this.handler.apply(_this, __slice.call(task.slice(1, -1)).concat([(_this._handler_callback = handler_callback)]));
        };
      })(this));
    };

    Worker.prototype.continue_group = function(group) {
      this.redis.watch("" + (this.key('QUEUED')) + ":" + group);
      return this.redis.lindex("" + (this.key('QUEUED')) + ":" + group, 1, (function(_this) {
        return function(err, res) {
          var task;
          if (task = JSON.parse(res)) {
            _this.redis.unwatch();
            _this.redis.lpop("" + (_this.key('QUEUED')) + ":" + group);
            if (exiting) {
              return _this.requeue(group);
            }
            return _this.process(task);
          } else {
            return _this.redis.multi().lpop("" + (_this.key('QUEUED')) + ":" + group).exec(function(multi_err, multi_res) {
              if (!multi_res) {
                return _this.continue_group(group);
              }
              return _this.start();
            });
          }
        };
      })(this));
    };

    Worker.prototype.requeue = function(group) {
      this.redis.watch("" + (this.key('QUEUED')) + ":" + group);
      return this.redis.lrange("" + (this.key('QUEUED')) + ":" + group, 0, -1, (function(_this) {
        return function(err, res) {
          var _ref;
          return (_ref = _this.redis.multi()).lpush.apply(_ref, ["" + (_this.key('SOURCE'))].concat(__slice.call(res.reverse()))).del("" + (_this.key('QUEUED')) + ":" + group).exec(function(multi_err, multi_res) {
            if (!multi_res) {
              return _this.requeue(group);
            }
            return _this.unregist();
          });
        };
      })(this));
    };

    Worker.prototype.unregist = function(callback) {
      return this.redis.hdel(this.key('WORKERS'), this.id, (function(_this) {
        return function(err, res) {
          workers.splice(workers.indexOf(_this), 1);
          if (workers.length) {
            return;
          }
          if (callback) {
            return callback();
          } else {
            return process.exit(uncaught_exception_happened ? 8 : 0);
          }
        };
      })(this));
    };

    return Worker;

  })();

}).call(this);
